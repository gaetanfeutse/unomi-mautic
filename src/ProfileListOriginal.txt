import React, { useState, useEffect } from 'react';
import '../ProfileList.css';

function ProfileList() {
  const [profiles, setProfiles] = useState([]);
  const [searchTerm, setSearchTerm] = useState('');
  const [currentPage, setCurrentPage] = useState(1);
  const profilesPerPage = 10;
  const [showAnonymous, setShowAnonymous] = useState(true);

  // Fetch profiles when the component mounts
  useEffect(() => {
    fetchProfiles();
  }, []);

  // Function to fetch profiles from the Unomi instance
  const fetchProfiles = async () => {
    try {
      const response = await fetch('https://cdp.qilinsa.com:9443/cxs/profiles/search', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Basic ' + btoa('karaf:karaf')
        },
        body: JSON.stringify({
          offset: 0,
          limit: 1000
        })
      });
      const data = await response.json();
      setProfiles(data.list);
    } catch (error) {
      console.error('Error fetching profiles:', error);
    }
  };

  // Handle changes in the search input
  const handleSearchChange = (e) => {
    setSearchTerm(e.target.value);
  };

  // Handle pagination page changes
  const handlePageChange = (pageNumber) => {
    setCurrentPage(pageNumber);
  };

  // Toggle the display of anonymous profiles
  const handleShowAnonymousChange = () => {
    setShowAnonymous(!showAnonymous);
  };

  // Check if a profile is anonymous
  const isAnonymous = (profile) => {
    const firstName = profile.properties?.firstName || '';
    const lastName = profile.properties?.lastName || '';
    const email = profile.properties?.email || '';
    return !firstName && !lastName && !email;
  };

  // Filter profiles based on search term and anonymity
  const filteredProfiles = profiles.filter(profile => {
    if (!showAnonymous && isAnonymous(profile)) {
      return false;
    }
    const firstName = profile.properties?.firstName || '';
    const lastName = profile.properties?.lastName || '';
    const email = profile.properties?.email || '';
    return (
      firstName.toLowerCase().includes(searchTerm.toLowerCase()) ||
      lastName.toLowerCase().includes(searchTerm.toLowerCase()) ||
      email.toLowerCase().includes(searchTerm.toLowerCase())
    );
  });

  // Pagination logic
  const indexOfLastProfile = currentPage * profilesPerPage;
  const indexOfFirstProfile = indexOfLastProfile - profilesPerPage;
  const currentProfiles = filteredProfiles.slice(indexOfFirstProfile, indexOfLastProfile);
  const pageNumbers = [];

  for (let i = 1; i <= Math.ceil(filteredProfiles.length / profilesPerPage); i++) {
    pageNumbers.push(i);
  }

  // Delete a profile by its ID
  const deleteProfile = async (profileId) => {
    try {
      await fetch(`https://cdp.qilinsa.com:9443/cxs/profiles/${profileId}`, {
        method: 'DELETE',
        headers: {
          'Authorization': 'Basic ' + btoa('karaf:karaf')
        }
      });
      setProfiles(profiles.filter(profile => profile.itemId !== profileId));
    } catch (error) {
      console.error('Error deleting profile:', error);
    }
  };

  return (
    <div className="profile-list">
      <h2>Profile List</h2>
      <input
        type="text"
        placeholder="Search profiles..."
        value={searchTerm}
        onChange={handleSearchChange}
      />
      <div>
        <input
          type="checkbox"
          checked={showAnonymous}
          onChange={handleShowAnonymousChange}
        />
        <label>Show Anonymous Profiles</label>
      </div>
      <ul>
        {currentProfiles.map(profile => (
          <li key={profile.itemId} className="profile-item">
            <h3>{profile.properties?.firstName} {profile.properties?.lastName}</h3>
            <p>ID: {profile.itemId}</p>
            <p>Email: {profile.properties?.email}</p>
            <p>Number of Visits: {profile.properties?.nbOfVisits}</p>
            <p>First Visit: {profile.properties?.firstVisit ? new Date(profile.properties.firstVisit).toLocaleString() : 'N/A'}</p>
            <p>Last Visit: {profile.properties?.lastVisit ? new Date(profile.properties.lastVisit).toLocaleString() : 'N/A'}</p>
            <p>Last Updated: {profile.systemProperties?.lastUpdated ? new Date(profile.systemProperties.lastUpdated).toLocaleString() : 'N/A'}</p>
            <p>Segments: {profile.segments?.join(', ')}</p>
            <button onClick={() => deleteProfile(profile.itemId)}>Delete</button>
          </li>
        ))}
      </ul>
      <div className="pagination">
        {pageNumbers.map(number => (
          <button
            key={number}
            onClick={() => handlePageChange(number)}
            className={currentPage === number ? 'active' : ''}
          >
            {number}
          </button>
        ))}
      </div>
    </div>
  );
}

export default ProfileList;
