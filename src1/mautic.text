import React, { useState, useEffect } from 'react';
import '../ProfileList.css';

function ProfileList() {
  const [profiles, setProfiles] = useState([]);
  const [searchTerm, setSearchTerm] = useState('');
  const [currentPage, setCurrentPage] = useState(1);
  const [profilesPerPage] = useState(10);
  const [showAnonymous, setShowAnonymous] = useState(true);

  // Fetch profiles when the component mounts
  useEffect(() => {
    fetchProfiles();

    // Set up WebSocket connection
    const ws = new WebSocket('wss://cdp.qilinsa.com:9443/profiles/stream');
    ws.onmessage = (event) => {
      const newProfile = JSON.parse(event.data);
      setProfiles((prevProfiles) => [...prevProfiles, newProfile]);
      addProfileToMautic(newProfile);
    };

    // Clean up WebSocket connection when component unmounts
    return () => {
      ws.close();
    };
  }, []);

  // Function to fetch profiles from the Unomi instance
  const fetchProfiles = async () => {
    try {
      const response = await fetch('https://cdp.qilinsa.com:9443/cxs/profiles/search', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Basic ' + btoa('karaf:karaf')
        },
        body: JSON.stringify({
          offset: 0,
          limit: 1000
        })
      });
      const data = await response.json();
      setProfiles(data.list);
    } catch (error) {
      console.error('Error fetching profiles:', error);
    }
  };

  // Function to add profile to Mautic
  const addProfileToMautic = async (profile) => {
    try {
      await fetch('https://marketing.qilinsa.com/api/contacts/new', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Basic ' + btoa('gaetan.feutse:Qilinsa237@4321?')
        },
        body: JSON.stringify({
          email: profile.properties?.email,
          firstname: profile.properties?.firstName,
          lastname: profile.properties?.lastName,
          ipAddress: profile.properties?.lastVisit // Example of other profile properties you might want to add
        })
      });
    } catch (error) {
      console.error('Error adding profile to Mautic:', error);
    }
  };

  // Function to delete profile from Unomi and Mautic
  const deleteProfile = async (profile) => {
    try {
      // Delete from Unomi
      await fetch(`https://cdp.qilinsa.com:9443/cxs/profiles/${profile.itemId}`, {
        method: 'DELETE',
        headers: {
          'Authorization': 'Basic ' + btoa('karaf:karaf')
        }
      });

      // Delete from Mautic
      const email = profile.properties?.email;
      if (email) {
        const mauticResponse = await fetch(`https://marketing.qilinsa.com/api/contacts?search=${email}`, {
          headers: {
            'Authorization': 'Basic ' + btoa('gaetan.feutse:Qilinsa237@4321?')
          }
        });
        const mauticData = await mauticResponse.json();
        const mauticContact = mauticData.contacts[Object.keys(mauticData.contacts)[0]];
        if (mauticContact) {
          await fetch(`https://marketing.qilinsa.com/api/contacts/${mauticContact.id}/delete`, {
            method: 'DELETE',
            headers: {
              'Authorization': 'Basic ' + btoa('gaetan.feutse:Qilinsa237@4321?')
            }
          });
        }
      }

      // Update profile list
      setProfiles(profiles.filter(p => p.itemId !== profile.itemId));
    } catch (error) {
      console.error('Error deleting profile:', error);
    }
  };

  // Handle changes in the search input
  const handleSearchChange = (e) => {
    setSearchTerm(e.target.value);
  };

  // Handle pagination page changes
  const handlePageChange = (pageNumber) => {
    setCurrentPage(pageNumber);
  };

  // Toggle the display of anonymous profiles
  const handleShowAnonymousChange = () => {
    setShowAnonymous(!showAnonymous);
  };

  // Check if a profile is anonymous
  const isAnonymous = (profile) => {
    const firstName = profile.properties?.firstName || '';
    const lastName = profile.properties?.lastName || '';
    const email = profile.properties?.email || '';
    return !firstName && !lastName && !email;
  };

  // Filter profiles based on search term and anonymity
  const filteredProfiles = profiles.filter(profile => {
    if (!showAnonymous && isAnonymous(profile)) {
      return false;
    }
    const firstName = profile.properties?.firstName || '';
    const lastName = profile.properties?.lastName || '';
    const email = profile.properties?.email || '';
    return (
      firstName.toLowerCase().includes(searchTerm.toLowerCase()) ||
      lastName.toLowerCase().includes(searchTerm.toLowerCase()) ||
      email.toLowerCase().includes(searchTerm.toLowerCase())
    );
  });

  // Pagination logic
  const indexOfLastProfile = currentPage * profilesPerPage;
  const indexOfFirstProfile = indexOfLastProfile - profilesPerPage;
  const currentProfiles = filteredProfiles.slice(indexOfFirstProfile, indexOfLastProfile);
  const pageNumbers = [];

  for (let i = 1; i <= Math.ceil(filteredProfiles.length / profilesPerPage); i++) {
    pageNumbers.push(i);
  }

  return (
    <div className="profile-list">
      <h2>Profile List</h2>
      <input
        type="text"
        placeholder="Search profiles..."
        value={searchTerm}
        onChange={handleSearchChange}
      />
      <div>
        <input
          type="checkbox"
          checked={showAnonymous}
          onChange={handleShowAnonymousChange}
        />
        <label>Show Anonymous Profiles</label>
      </div>
      <ul>
        {currentProfiles.map(profile => (
          <li key={profile.itemId} className="profile-item">
            <h3>{profile.properties?.firstName} {profile.properties?.lastName}</h3>
            <p>Email: {profile.properties?.email}</p>
            <p>Number of Visits: {profile.properties?.nbOfVisits}</p>
            <p>First Visit: {profile.properties?.firstVisit ? new Date(profile.properties.firstVisit).toLocaleString() : 'N/A'}</p>
            <p>Last Visit: {profile.properties?.lastVisit ? new Date(profile.properties.lastVisit).toLocaleString() : 'N/A'}</p>
            <p>Last Updated: {profile.systemProperties?.lastUpdated ? new Date(profile.systemProperties.lastUpdated).toLocaleString() : 'N/A'}</p>
            <p>Segments: {profile.segments?.join(', ')}</p>
            <button onClick={() => deleteProfile(profile)}>Delete</button>
          </li>
        ))}
      </ul>
      <div className="pagination">
        {pageNumbers.map(number => (
          <button
            key={number}
            onClick={() => handlePageChange(number)}
            className={currentPage === number ? 'active' : ''}
          >
            {number}
          </button>
        ))}
      </div>
    </div>
  );
}

export default ProfileList;
